Static Analysis with LLM


2024.4.15  BaiJun Cheng


1


Contents


1. KernelGPT: Enhanced Kernel Fuzzing via Large Language Models

2. When Dataflow Analysis Meets Large Language Models


2


1.KernelGPT: Enhanced Kernel Fuzzing via Large Language Models


Chenyuan Yang,    Zijie Zhao,   Lingming Zhang

University of Illinois Urbana-Champaign


3


1-1.intro


kernel fuzzing techniques Syzkaller can be enhanced via seed generation, seed selection, guided mutation, syscall specification generation. the syscall descriptions written in syzlang. 


4


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_3_1.png" width="838" height="362"/>


requiring human-defined rules


more flexible


1-1.intro


SyzDescribe typically rely on the .name field in struct miscdevice to determine the device name for driver inter-action, which is a conventional use case.


5


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_4_1.png" width="415" height="278"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_4_2.png" width="371" height="276"/>


Solution-LLM: 
1.deduce the device name and its initialization descriptions
2. recover the command values, argument types, and type definitions
3. validates and repairs the generated specification


1-1.intro


SyzDescribe typically rely on the .name field in struct miscdevice to determine the device name for driver inter-action, which is a conventional use case.


6


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_5_1.png" width="415" height="278"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_5_2.png" width="371" height="276"/>


Solution-LLM: 
1.deduce the device name and its initialization descriptions
2. recover the command values, argument types, and type definitions
3. validates and repairs the generated specification


1-2.Background


KernelGPT focus on testing devices. Each device is a file in Linux. Developer will  implement "ioctl(int fd, unsigned long request, void *argp) ” syscall to invoke kernel functions like open, close. fd is  file descriptor of device, request is command identifier to select operation. argp is cast to driver-specific data types to carry information in and out.


7


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_6_1.png" width="581" height="272"/>


name of MSM device.


type of argument of syscall ioctl.


Challenges:
1. Extract expected parameter values and type definitions
2. Infer dependencies among syscalls and encode the dependencies in parameter


1-3.Approach


8


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_7_1.png" width="1120" height="396"/>


Critical Components: Device Name, Command Value, Argument Type


1-3-1. Device Name


9


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_8_1.png" width="584" height="456"/>


Requiring:

- Operation Handler: The initialization of struct variable including file operation.

- Usage: The refered site of the file operation struct variable.


1-3-2. Command Value


10


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_9_1.png" width="541" height="410"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_9_2.png" width="506" height="396"/>


Continue analyzing through a call-chain to extract command value. In this step, KernelGPT extract command value DM_VERSION while baseline SyzDescribe wrongly extract DM_VERSION_CMD.


1-3-3. Argument Type


11


After identify command value, the corresponding handler function is determined. LLM could analyze the argument type of syscall ioctl with the definition of handler function. After identify corresponding type, LLM could be used to translate the type definition from C into syzlang.


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_10_1.png" width="521" height="393"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_10_2.png" width="513" height="249"/>


1-4. Evaluation


12


RQ1: What is the number and quality of the specifications for undescribed kernel drivers generated by KernelGPT?
RQ2: What is the quality of the syscall descriptions generated by KernelGPT compared to the baselines?
RQ3: Can specifications generated by KernelGPT detect real-world bugs in the kernel?


RQ1: Integrating specifications synthesized by KernelGPT for the undescribed drivers resulting in 28.6% more crashes being triggered with an additional 1.5K lines covered compared to manually written specifications.


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_11_1.png" width="767" height="224"/>


RQ2: coverage is higher than baseline


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_11_2.png" width="429" height="189"/>


RQ3: detect 8 bugs with 7 previously unknown


2.When Dataflow Analysis Meets Large Language Models


Chengpeng Wang[1],   Wuqi Zhang[2],  Zian Su[1],  Xiangzhe Xu[1],  Xiaoheng Xie[2],  Xiangyu Zhang[1]


1.Purdue University
2.The Hong Kong University of Science and Technology


13


14


2-1.intro


Limitation of current data-flow engines:
1. rely on program intermediate representations (IRs) generated by semantic analyzers in the frontends of compilation infrastructures, limited in analyzing incomplete 
2. requires expert knowledge and manual effort.


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_13_1.png" width="592" height="344"/>


Challenge:
1. path feasibility validation
2. Incorrect dataflow facts in single functions can accumulate and magnify


15


2-2.method


1. Source/Sink Extraction
2. Dataflow Summarization: identifies the dataflow facts from v ∈ Vsrc ∪ Vpar ∪ Vout to v′ ∈ Vsink ∪ Varg ∪ Vret 
3. Path feasibility Validation:  validates the path feasibility by generate SMT queries. 


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_14_1.png" width="1134" height="244"/>


16


2-2-1.Source/Sink Extraction


synthesizing source/sink extractors with specific patterns by LLM. Input:

Specification


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_15_1.png" width="537" height="264"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_15_2.png" width="560" height="354"/>


17


2-2-2.Dataflow Summarization


Determing whether two values are reachable. Input:

function (main)

line1-var1 (line9-x)

line2-var2 (line13-z)


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_16_1.png" width="541" height="392"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_16_2.png" width="477" height="290"/>


18


2-2-3. Path Feasibility Validation


LLMs cannot achieve adequate performance on constraint solving. Hence, LLMDFA prompt LLM to synthesize a Python script program to solve the constraint. Input:

1.Data Flow Path (lines of code)

2.Branch conditions


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_17_1.png" width="589" height="297"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_17_2.png" width="322" height="212"/>


a script for expression: Math.abs(b) > 1


19


2-3. Evaluation


LLM: gpt-3.5-turbo-1106
benchmark: Juliet Test Suite (XSS and DBZ(division by zero)), including 1,850 DBZ and 666 XSS bugs


 Comparison with Baselines


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_18_1.png" width="530" height="294"/>


<img src="/home/wgy/reading_group/LLM-Reading-Group/Markdown/Images/2024-04-15/img_18_2.png" width="412" height="209"/>


 Comparison with end-to-end analysis


 Ablation


20


Thanks

